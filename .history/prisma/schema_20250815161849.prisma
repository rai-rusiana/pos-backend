// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  //output   = "../generated/prisma"
}

datasource db {
  // provider = "postgresql" production
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  MANAGER
  STAFF
  CASHIER
}

enum OutletType {
  retail
  wholesale
  service
}

model User {
  id           Int      @id @default(autoincrement())
  fullname     String
  username     String   @unique
  email        String   @unique
  role         Role     @default(CASHIER) // This is a user's global role
  password     String // bcrypt hash only, never plain text
  createdAt    DateTime @default(now())
  profilePhoto String?

  // Relationships
  branchesOwned Branch[]     @relation("UserBranches") // One user can own multiple branches
  storesOwned   Store[]      @relation("UserStores") // One user can own multiple stores
  storeStaff    StoreStaff[] // A user can be staff at multiple stores

  Transaction Transaction[]
}

model Branch {
  id       Int      @id @default(autoincrement())
  name     String
  address  String
  phone    String?
  isActive Boolean  @default(true)
  createAt DateTime @default(now())

  // Relationship to User (Owner)
  ownerId Int
  owner   User @relation("UserBranches", fields: [ownerId], references: [id])

  // Relationship to Store (A branch can have one or more stores)
  stores Store[]
}

model Store {
  id                    Int        @id @default(autoincrement())
  name                  String
  address               String
  phone                 String?
  code                  String     @unique // Added unique constraint for clarity
  nextTransactionNumber Int?       @default(1)
  governmentTax         Float?
  serviceCharge         Float?
  outletType            OutletType
  isActive              Boolean    @default(true)
  wifiSSID              String? // Made optional, as not all stores might have it

  // Relationship to Branch
  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  // Relationship to User (Owner)
  ownerId Int
  owner   User @relation("UserStores", fields: [ownerId], references: [id])

  // Relationship to Staff (A store can have one or more staff)
  staff StoreStaff[]

  // Other relationships (if needed)
  devices   Device[]
  inventory Inventory? // This is a one-to-one relationship

  Transaction Transaction[]
}

model StoreStaff {
  id      Int  @id @default(autoincrement())
  storeId Int
  userId  Int
  role    Role // This is a store-specific role

  // Relationships
  store Store @relation(fields: [storeId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@unique([storeId, userId]) // Ensures a user can't be added to the same store twice
}

model Device {
  id       Int    @id @default(autoincrement())
  deviceId String @unique
  store    Store  @relation(fields: [storeId], references: [id])
  storeId  Int

  Transaction Transaction[]
}

model UnauthorizedAttempt {
  id                Int      @id @default(autoincrement())
  storeId           Int
  attemptedDeviceId String
  timestamp         DateTime @default(now())
}

model Inventory {
  id      Int              @id @default(autoincrement())
  name    String?
  storeId Int              @unique
  store   Store            @relation(fields: [storeId], references: [id])
  items   InventoryItems[]
}

model InventoryItems {
  id          Int       @id @default(autoincrement())
  inventoryId Int
  inventory   Inventory @relation(fields: [inventoryId], references: [id])
  itemId      Int
  item        Item      @relation(fields: [itemId], references: [id])
  quantity    Int       @default(0)
  locationId  Int?      @unique
  location    Location? @relation(fields: [locationId], references: [id], onDelete: SetNull)
  @@unique([inventoryId, itemId])
}

model Location {
  id    Int             @id @default(autoincrement())
  aisle String
  rack  String
  shelf String
  item  InventoryItems?
}

model Category {
  id   Int    @id @default(autoincrement())
  name String
  Item Item[]
}
model Color {
  id      Int      @id @default(autoincrement())
  name    String   @unique
  hexCode String?
  items   Item[] // A color can be associated with many items
}
model Item {
  id             Int              @id @default(autoincrement())
  name           String
  price          Float
  image          String?
  color          Color[]
  brand          String?
  categoryId     Int?
  category       Category?         @relation(fields: [categoryId], references: [id], onDelete: SetNull )
  InventoryItems InventoryItems[]
  cartItems      CartItem[]
}

model CartItem {
  // A transaction can have many items, and an item can be in many transactions.
  // This model links them and stores the quantity for each.
  transactionId Int
  itemId        Int
  quantity      Int

  transaction Transaction @relation(fields: [transactionId], references: [id])
  item        Item        @relation(fields: [itemId], references: [id])

  // A composite primary key ensures each item appears only once per transaction.
  @@id([transactionId, itemId])
}

enum PaymentMethod {
  CARD
  CASH
  DIGITAL
}

enum Status {
  PENDING
  SYNCED
  FAILED
  CANCELED
}

model Transaction {
  id            Int           @id @default(autoincrement())
  storeId       Int
  store         Store         @relation(fields: [storeId], references: [id])
  cashierId     Int
  cashier       User          @relation(fields: [cashierId], references: [id])
  deviceId      Int
  device        Device        @relation(fields: [deviceId], references: [id])
  items         CartItem[]
  total         Float
  tax           Float
  subtotal      Float
  cashReceived  Float
  change        Float
  paymentMethod PaymentMethod
  status        Status
  createdAt     DateTime
  syncedAt      DateTime      @default(now())
  retryCount    Int
}
